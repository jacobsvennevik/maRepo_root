{"version":3,"sources":["/Users/jacobhornsvennevik/Documents/GitHub/maRepo_root/frontend/src/features/projects/services/hybrid-test-utils.ts"],"sourcesContent":["// Hybrid test utilities - Use mock data but process through real backend\nimport { axiosApi } from '@/lib/axios-api';\nimport { \n  MOCK_SYLLABUS_PROCESSED_DOCUMENT, \n  MOCK_COURSE_CONTENT_PROCESSED_DOCUMENT,\n  MOCK_PROCESSED_TESTS,\n  simulateProcessingDelay \n} from '../services/mock-data';\n\nexport interface MockBackendResponse {\n  id: number;\n  original_text: string;\n  metadata: any;\n  status: 'pending' | 'processing' | 'completed' | 'error';\n  processed_data?: any;\n}\n\n/**\n * Set test mode environment variable for backend\n */\nfunction setTestModeEnvironment() {\n  // Set a custom header to indicate test mode\n  if (axiosApi.defaults && axiosApi.defaults.headers) {\n    if (!axiosApi.defaults.headers.common) {\n      axiosApi.defaults.headers.common = {};\n    }\n    axiosApi.defaults.headers.common['X-Test-Mode'] = 'true';\n  }\n  \n  // Also try to set environment variable (may not work in browser)\n  if (typeof window !== 'undefined') {\n    (window as any).TEST_MODE = 'true';\n  }\n}\n\n/**\n * Create mock File objects for testing\n */\nfunction createMockFiles(fileNames: string[], uploadType: string): File[] {\n  return fileNames.map((fileName, index) => {\n    const content = `Mock ${uploadType} content for ${fileName}`;\n    const blob = new Blob([content], { type: 'application/pdf' });\n    return new File([blob], fileName, { type: 'application/pdf' });\n  });\n}\n\n/**\n * Upload mock data to backend and get real processing response\n */\nexport async function uploadMockDataToBackend(\n  mockData: any, \n  uploadType: string,\n  fileName: string\n): Promise<MockBackendResponse> {\n  console.log(`ðŸ§ª HYBRID MODE: Uploading mock data for ${fileName} to real backend`);\n  \n  // Set test mode environment\n  setTestModeEnvironment();\n  \n  try {\n    // Create a mock file from the mock data\n    const mockFile = createMockFileFromData(mockData, fileName);\n    \n    // Upload to real backend\n    const formData = new FormData();\n    formData.append('file', mockFile);\n    formData.append('file_type', 'pdf');\n    formData.append('upload_type', uploadType);\n\n    const uploadResponse = await axiosApi.post('pdf_service/documents/', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data',\n        'X-Test-Mode': 'true', // Ensure test mode header is set\n      }\n    });\n    \n    console.log(`ðŸ§ª HYBRID MODE: Mock data uploaded successfully:`, uploadResponse.data);\n    \n    // Return the real backend response with mock data\n    return {\n      ...uploadResponse.data,\n      original_text: mockData.original_text || \"Mock document content\",\n      metadata: mockData.metadata || mockData,\n      processed_data: mockData.metadata || mockData\n    };\n    \n  } catch (error) {\n    console.error(`ðŸ§ª HYBRID MODE: Failed to upload mock data:`, error);\n    \n    // Fallback to pure mock data if backend fails\n    return {\n      id: Math.floor(Math.random() * 1000),\n      original_text: mockData.original_text || \"Mock document content\",\n      metadata: mockData.metadata || mockData,\n      status: 'completed',\n      processed_data: mockData.metadata || mockData\n    };\n  }\n}\n\n/**\n * Process mock data through real backend pipeline\n */\nexport async function processMockDataThroughBackend(\n  documentId: number,\n  mockData: any\n): Promise<MockBackendResponse> {\n  console.log(`ðŸ§ª HYBRID MODE: Processing mock data through real backend pipeline`);\n  \n  // Set test mode environment\n  setTestModeEnvironment();\n  \n  try {\n    // Start real backend processing\n    const processResponse = await axiosApi.post(`pdf_service/documents/${documentId}/process/`, {}, {\n      headers: {\n        'X-Test-Mode': 'true', // Ensure test mode header is set\n      }\n    });\n    console.log(`ðŸ§ª HYBRID MODE: Real processing started:`, processResponse.data);\n    \n    // Simulate processing time (realistic delay)\n    await simulateProcessingDelay(2000, 4000);\n    \n    // Poll for completion\n    const maxAttempts = 15;\n    const pollInterval = 2000;\n    let attempts = 0;\n    \n    while (attempts < maxAttempts) {\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n      \n      try {\n        const statusResponse = await axiosApi.get(`pdf_service/documents/${documentId}/`, {\n          headers: {\n            'X-Test-Mode': 'true', // Ensure test mode header is set\n          }\n        });\n        const statusData = statusResponse.data;\n        \n        console.log(`ðŸ§ª HYBRID MODE: Polling attempt ${attempts + 1}:`, statusData.status);\n        \n        if (statusData.status === 'completed') {\n          console.log(`ðŸ§ª HYBRID MODE: Real processing completed, using mock data as fallback`);\n          \n          // Get the processed data from backend\n          const processedDataResponse = await axiosApi.get(`pdf_service/documents/${documentId}/processed_data/`, {\n            headers: {\n              'X-Test-Mode': 'true', // Ensure test mode header is set\n            }\n          });\n          \n          return {\n            id: documentId,\n            original_text: mockData.original_text || \"Mock document content\",\n            metadata: processedDataResponse.data?.data || mockData.metadata || mockData,\n            status: 'completed',\n            processed_data: processedDataResponse.data?.data || mockData.metadata || mockData\n          };\n        }\n        \n        attempts += 1;\n      } catch (pollError) {\n        console.error(`ðŸ§ª HYBRID MODE: Polling error:`, pollError);\n        attempts += 1;\n      }\n    }\n    \n    console.log(`ðŸ§ª HYBRID MODE: Processing timeout, using mock data as fallback`);\n    \n    // Return mock data as fallback\n    return {\n      id: documentId,\n      original_text: mockData.original_text || \"Mock document content\",\n      metadata: mockData.metadata || mockData,\n      status: 'completed',\n      processed_data: mockData.metadata || mockData\n    };\n    \n  } catch (error) {\n    console.error(`ðŸ§ª HYBRID MODE: Processing failed, using mock data:`, error);\n    \n    // Return mock data as fallback\n    return {\n      id: documentId,\n      original_text: mockData.original_text || \"Mock document content\",\n      metadata: mockData.metadata || mockData,\n      status: 'completed',\n      processed_data: mockData.metadata || mockData\n    };\n  }\n}\n\n/**\n * Create a mock file from mock data\n */\nfunction createMockFileFromData(mockData: any, fileName: string): File {\n  // Create a simple text representation of the mock data\n  const content = JSON.stringify(mockData, null, 2);\n  const blob = new Blob([content], { type: 'application/pdf' });\n  return new File([blob], fileName, { type: 'application/pdf' });\n}\n\n/**\n * Get appropriate mock data based on upload type\n */\nexport function getMockDataForType(uploadType: string, fileName: string): any {\n  switch (uploadType) {\n    case 'syllabus':\n      return MOCK_SYLLABUS_PROCESSED_DOCUMENT;\n    case 'learning_materials':\n    case 'course_content':\n      return MOCK_COURSE_CONTENT_PROCESSED_DOCUMENT;\n    case 'test_files':\n      return MOCK_PROCESSED_TESTS[0];\n    default:\n      return MOCK_SYLLABUS_PROCESSED_DOCUMENT;\n  }\n}\n\n/**\n * Enhanced hybrid upload and process function that properly updates state\n */\nexport async function hybridUploadAndProcess(\n  files: File[],\n  uploadType: string,\n  onProgress?: (progress: number) => void,\n  onStateUpdate?: (files: File[], data: any[]) => void\n): Promise<MockBackendResponse[]> {\n  console.log(`ðŸ§ª HYBRID MODE: Processing ${files.length} files through real backend with mock data`);\n  \n  // Set test mode environment\n  setTestModeEnvironment();\n  \n  const results: MockBackendResponse[] = [];\n  \n  for (let i = 0; i < files.length; i++) {\n    const file = files[i];\n    \n    // Update progress\n    if (onProgress) {\n      onProgress((i / files.length) * 50); // First 50% for upload\n    }\n    \n    // Get appropriate mock data\n    const mockData = getMockDataForType(uploadType, file.name);\n    \n    try {\n      // Upload mock data to real backend\n      const uploadResult = await uploadMockDataToBackend(mockData, uploadType, file.name);\n      \n      // Update progress\n      if (onProgress) {\n        onProgress(50 + (i / files.length) * 25); // 50-75% for processing\n      }\n      \n      // Process through real backend\n      const processResult = await processMockDataThroughBackend(uploadResult.id, mockData);\n      \n      // Update progress\n      if (onProgress) {\n        onProgress(75 + (i / files.length) * 25); // 75-100% for completion\n      }\n      \n      results.push(processResult);\n      \n    } catch (error) {\n      console.error(`ðŸ§ª HYBRID MODE: Failed to process ${file.name}:`, error);\n      \n      // Fallback to pure mock data\n      results.push({\n        id: Math.floor(Math.random() * 1000),\n        original_text: mockData.original_text || \"Mock document content\",\n        metadata: mockData.metadata || mockData,\n        status: 'completed',\n        processed_data: mockData.metadata || mockData\n      });\n    }\n  }\n  \n  // ðŸ”§ CRITICAL FIX: Update parent state with files and data\n  // This ensures the Next button gets activated\n  if (onStateUpdate) {\n    console.log(`ðŸ§ª HYBRID MODE: Updating parent state with ${files.length} files and ${results.length} results`);\n    onStateUpdate(files, results);\n  }\n  \n  return results;\n}\n\n/**\n * Enhanced mock upload function that properly handles state updates\n */\nexport async function enhancedMockUpload(\n  files: File[],\n  uploadType: string,\n  onProgress?: (progress: number) => void,\n  onStateUpdate?: (files: File[], data: any[]) => void\n): Promise<MockBackendResponse[]> {\n  console.log(`ðŸ§ª ENHANCED MOCK: Processing ${files.length} files with proper state updates`);\n  \n  // Simulate realistic processing time\n  const totalTime = 2000 + Math.random() * 2000;\n  const stepTime = totalTime / files.length;\n  \n  const results: MockBackendResponse[] = [];\n  \n  for (let i = 0; i < files.length; i++) {\n    const file = files[i];\n    \n    // Update progress\n    if (onProgress) {\n      onProgress((i / files.length) * 100);\n    }\n    \n    // Get appropriate mock data\n    const mockData = getMockDataForType(uploadType, file.name);\n    \n    // Simulate processing delay\n    await new Promise(resolve => setTimeout(resolve, stepTime));\n    \n    // Create mock result\n    const mockResult: MockBackendResponse = {\n      id: Math.floor(Math.random() * 1000) + i,\n      original_text: mockData.original_text || `Mock content for ${file.name}`,\n      metadata: mockData.metadata || mockData,\n      status: 'completed',\n      processed_data: mockData.metadata || mockData\n    };\n    \n    results.push(mockResult);\n  }\n  \n  // ðŸ”§ CRITICAL FIX: Update parent state with files and data\n  // This ensures the Next button gets activated\n  if (onStateUpdate) {\n    console.log(`ðŸ§ª ENHANCED MOCK: Updating parent state with ${files.length} files and ${results.length} results`);\n    onStateUpdate(files, results);\n  }\n  \n  return results;\n} "],"names":["enhancedMockUpload","getMockDataForType","hybridUploadAndProcess","processMockDataThroughBackend","uploadMockDataToBackend","setTestModeEnvironment","axiosApi","defaults","headers","common","window","TEST_MODE","createMockFiles","fileNames","uploadType","map","fileName","index","content","blob","Blob","type","File","mockData","console","log","mockFile","createMockFileFromData","formData","FormData","append","uploadResponse","post","data","original_text","metadata","processed_data","error","id","Math","floor","random","status","documentId","processResponse","simulateProcessingDelay","maxAttempts","pollInterval","attempts","Promise","resolve","setTimeout","statusResponse","get","statusData","processedDataResponse","pollError","JSON","stringify","MOCK_SYLLABUS_PROCESSED_DOCUMENT","MOCK_COURSE_CONTENT_PROCESSED_DOCUMENT","MOCK_PROCESSED_TESTS","files","onProgress","onStateUpdate","length","results","i","file","name","uploadResult","processResult","push","totalTime","stepTime","mockResult"],"mappings":"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"}