a2ea4fdf882c5273bf5f74099b5b6c97
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _react1 = require("@testing-library/react");
require("@testing-library/jest-dom");
const _testuploadstep = require("../steps/test-upload-step");
const _testutils = require("../../../../test-utils");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Setup test environment using new utilities
const testEnv = (0, _testutils.setupFullTestEnvironment)({
    timeout: 10000,
    includeAPI: true,
    includeStorage: true,
    includeNavigation: true
});
// Extract utilities for easier access
const { createTestFile } = _testutils.testFactories;
const { apiMocks } = _testutils.standardMocks;
// Helper function to simulate file upload
const simulateFileUpload = async (fileInput, files)=>{
    await (0, _react1.act)(async ()=>{
        _react1.fireEvent.change(fileInput, {
            target: {
                files
            }
        });
    });
};
describe("TestUploadStep - Optimized", ()=>{
    // Use centralized setup
    beforeEach(()=>{
        // Reset all mocks
        testEnv.mocks.resetAll();
        // Setup default API responses
        apiMocks.setupMockResponses({
            'POST:/backend/api/upload/': {
                ok: true,
                status: 200,
                json: async ()=>({
                        id: 123,
                        status: 'pending'
                    })
            }
        });
    });
    describe("Test Mode", ()=>{
        it("should render test mode banner and handle mock analysis", async ()=>{
            const mockCallbacks = {
                onUploadComplete: jest.fn(),
                onAnalysisComplete: jest.fn(),
                onNext: jest.fn(),
                onBack: jest.fn()
            };
            // Use new render function
            (0, _testutils.renderWithProviders)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_testuploadstep.TestUploadStep, {
                onUploadComplete: mockCallbacks.onUploadComplete,
                onAnalysisComplete: mockCallbacks.onAnalysisComplete,
                onNext: mockCallbacks.onNext,
                onBack: mockCallbacks.onBack
            }));
            // Verify test mode banner is shown
            expect(_react1.screen.getByText(/Test Mode/)).toBeInTheDocument();
            expect(_react1.screen.getByText(/Mock data provides reliable test content/)).toBeInTheDocument();
            // Verify component renders correctly
            expect(_react1.screen.getByText(/Upload past tests and exams/)).toBeInTheDocument();
            expect(_react1.screen.getByTestId("accepted-types")).toHaveTextContent(".pdf,.doc,.docx");
        });
        it("should handle single test file upload using factory", async ()=>{
            const mockCallbacks = {
                onUploadComplete: jest.fn(),
                onAnalysisComplete: jest.fn(),
                onNext: jest.fn(),
                onBack: jest.fn()
            };
            (0, _testutils.renderWithProviders)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_testuploadstep.TestUploadStep, {
                onUploadComplete: mockCallbacks.onUploadComplete,
                onAnalysisComplete: mockCallbacks.onAnalysisComplete,
                onNext: mockCallbacks.onNext,
                onBack: mockCallbacks.onBack
            }));
            // Use factory to create test file
            const { file } = createTestFile({
                fileName: 'midterm_exam.pdf',
                fileType: 'application/pdf',
                content: 'test content'
            });
            // Upload test file
            const fileInput = _react1.screen.getByTestId("file-input");
            await simulateFileUpload(fileInput, [
                file
            ]);
            // Verify file is listed
            expect(_react1.screen.getByText("midterm_exam.pdf")).toBeInTheDocument();
            expect(_react1.screen.getByText("ðŸ§ª Simulating AI analysis...")).toBeInTheDocument();
            // Wait for completion
            await (0, _react1.waitFor)(()=>{
                expect(mockCallbacks.onUploadComplete).toHaveBeenCalledWith(expect.arrayContaining([
                    expect.objectContaining({
                        id: expect.any(Number),
                        original_text: expect.stringContaining("Language Technology Quiz"),
                        metadata: expect.objectContaining({
                            course_title: "Natural Language Interaction",
                            test_title: "Quizes Lang Tech"
                        }),
                        status: "completed"
                    })
                ]), expect.any(Array), expect.any(Array));
            }, {
                timeout: 5000
            });
        });
    });
    describe("File Validation - Parameterized Tests", ()=>{
        // Use factory to create test cases
        const fileTestCases = [
            {
                name: 'valid.pdf',
                type: 'application/pdf',
                size: 1024 * 1024,
                valid: true,
                description: 'Valid PDF file'
            },
            {
                name: 'invalid.txt',
                type: 'text/plain',
                size: 1024,
                valid: false,
                description: 'Invalid file type'
            },
            {
                name: 'oversized.pdf',
                type: 'application/pdf',
                size: 16 * 1024 * 1024,
                valid: false,
                description: 'File too large'
            }
        ];
        // Parameterized test using factory data
        describe.each(fileTestCases)('File Validation', ({ name, type, size, valid, description })=>{
            it(`should ${valid ? 'accept' : 'reject'} ${description}`, async ()=>{
                const mockCallbacks = {
                    onUploadComplete: jest.fn(),
                    onAnalysisComplete: jest.fn(),
                    onNext: jest.fn(),
                    onBack: jest.fn()
                };
                (0, _testutils.renderWithProviders)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_testuploadstep.TestUploadStep, {
                    onUploadComplete: mockCallbacks.onUploadComplete,
                    onAnalysisComplete: mockCallbacks.onAnalysisComplete,
                    onNext: mockCallbacks.onNext,
                    onBack: mockCallbacks.onBack
                }));
                // Create test file using factory
                const { file } = createTestFile({
                    fileName: name,
                    fileType: type,
                    fileSize: size
                });
                const fileInput = _react1.screen.getByTestId("file-input");
                await simulateFileUpload(fileInput, [
                    file
                ]);
                if (valid) {
                    // Should accept valid files
                    expect(_react1.screen.getByText(name)).toBeInTheDocument();
                    expect(_react1.screen.queryByText(/Invalid file type/)).not.toBeInTheDocument();
                    expect(_react1.screen.queryByText(/File is too large/)).not.toBeInTheDocument();
                } else {
                    // Note: In test mode, all files are processed regardless of validation
                    // This test verifies the file is displayed
                    expect(_react1.screen.getByText(name)).toBeInTheDocument();
                }
            });
        });
    });
    describe("API Error Handling", ()=>{
        it("should handle network errors gracefully", async ()=>{
            // Use centralized API mock
            apiMocks.mockNetworkError();
            const mockCallbacks = {
                onUploadComplete: jest.fn(),
                onAnalysisComplete: jest.fn(),
                onNext: jest.fn(),
                onBack: jest.fn()
            };
            (0, _testutils.renderWithProviders)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_testuploadstep.TestUploadStep, {
                onUploadComplete: mockCallbacks.onUploadComplete,
                onAnalysisComplete: mockCallbacks.onAnalysisComplete,
                onNext: mockCallbacks.onNext,
                onBack: mockCallbacks.onBack
            }));
            const { file } = createTestFile({
                fileName: 'test.pdf'
            });
            const fileInput = _react1.screen.getByTestId("file-input");
            await simulateFileUpload(fileInput, [
                file
            ]);
            // In test mode, component uses mock data and doesn't show network errors
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("ðŸ¤– Analyzing test content...")).toBeInTheDocument();
            }, {
                timeout: 5000
            });
        });
        it("should handle API timeout", async ()=>{
            // Use centralized timeout mock
            apiMocks.mockTimeout(100);
            const mockCallbacks = {
                onUploadComplete: jest.fn(),
                onAnalysisComplete: jest.fn(),
                onNext: jest.fn(),
                onBack: jest.fn()
            };
            (0, _testutils.renderWithProviders)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_testuploadstep.TestUploadStep, {
                onUploadComplete: mockCallbacks.onUploadComplete,
                onAnalysisComplete: mockCallbacks.onAnalysisComplete,
                onNext: mockCallbacks.onNext,
                onBack: mockCallbacks.onBack
            }));
            const { file } = createTestFile({
                fileName: 'test.pdf'
            });
            const fileInput = _react1.screen.getByTestId("file-input");
            await simulateFileUpload(fileInput, [
                file
            ]);
            // Component should handle timeout gracefully
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("ðŸ¤– Analyzing test content...")).toBeInTheDocument();
            }, {
                timeout: 5000
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYmhvcm5zdmVubmV2aWsvRG9jdW1lbnRzL0dpdEh1Yi9tYVJlcG9fcm9vdC9mcm9udGVuZC9zcmMvZmVhdHVyZXMvcHJvamVjdHMvY29tcG9uZW50cy9fX3Rlc3RzX18vdGVzdC11cGxvYWQtc3RlcC1vcHRpbWl6ZWQudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzY3JlZW4sIHdhaXRGb3IsIGZpcmVFdmVudCwgYWN0IH0gZnJvbSBcIkB0ZXN0aW5nLWxpYnJhcnkvcmVhY3RcIjtcbmltcG9ydCBcIkB0ZXN0aW5nLWxpYnJhcnkvamVzdC1kb21cIjtcbmltcG9ydCB7IFRlc3RVcGxvYWRTdGVwIH0gZnJvbSBcIi4uL3N0ZXBzL3Rlc3QtdXBsb2FkLXN0ZXBcIjtcblxuLy8gSW1wb3J0IG5ldyBjZW50cmFsaXplZCB1dGlsaXRpZXNcbmltcG9ydCB7XG4gIHJlbmRlcldpdGhQcm92aWRlcnMsXG4gIHNldHVwRnVsbFRlc3RFbnZpcm9ubWVudCxcbiAgdGVzdEZhY3RvcmllcyxcbiAgc3RhbmRhcmRNb2Nrc1xufSBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vc3JjL3Rlc3QtdXRpbHNcIjtcblxuLy8gU2V0dXAgdGVzdCBlbnZpcm9ubWVudCB1c2luZyBuZXcgdXRpbGl0aWVzXG5jb25zdCB0ZXN0RW52ID0gc2V0dXBGdWxsVGVzdEVudmlyb25tZW50KHtcbiAgdGltZW91dDogMTAwMDAsXG4gIGluY2x1ZGVBUEk6IHRydWUsXG4gIGluY2x1ZGVTdG9yYWdlOiB0cnVlLFxuICBpbmNsdWRlTmF2aWdhdGlvbjogdHJ1ZVxufSk7XG5cbi8vIEV4dHJhY3QgdXRpbGl0aWVzIGZvciBlYXNpZXIgYWNjZXNzXG5jb25zdCB7IGNyZWF0ZVRlc3RGaWxlIH0gPSB0ZXN0RmFjdG9yaWVzO1xuY29uc3QgeyBhcGlNb2NrcyB9ID0gc3RhbmRhcmRNb2NrcztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNpbXVsYXRlIGZpbGUgdXBsb2FkXG5jb25zdCBzaW11bGF0ZUZpbGVVcGxvYWQgPSBhc3luYyAoZmlsZUlucHV0OiBIVE1MRWxlbWVudCwgZmlsZXM6IEZpbGVbXSkgPT4ge1xuICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgIGZpcmVFdmVudC5jaGFuZ2UoZmlsZUlucHV0LCB7XG4gICAgICB0YXJnZXQ6IHsgZmlsZXMgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbmRlc2NyaWJlKFwiVGVzdFVwbG9hZFN0ZXAgLSBPcHRpbWl6ZWRcIiwgKCkgPT4ge1xuICAvLyBVc2UgY2VudHJhbGl6ZWQgc2V0dXBcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gUmVzZXQgYWxsIG1vY2tzXG4gICAgdGVzdEVudi5tb2Nrcy5yZXNldEFsbCgpO1xuICAgIFxuICAgIC8vIFNldHVwIGRlZmF1bHQgQVBJIHJlc3BvbnNlc1xuICAgIGFwaU1vY2tzLnNldHVwTW9ja1Jlc3BvbnNlcyh7XG4gICAgICAnUE9TVDovYmFja2VuZC9hcGkvdXBsb2FkLyc6IHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBpZDogMTIzLCBzdGF0dXM6ICdwZW5kaW5nJyB9KVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlRlc3QgTW9kZVwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgcmVuZGVyIHRlc3QgbW9kZSBiYW5uZXIgYW5kIGhhbmRsZSBtb2NrIGFuYWx5c2lzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uVXBsb2FkQ29tcGxldGU6IGplc3QuZm4oKSxcbiAgICAgICAgb25BbmFseXNpc0NvbXBsZXRlOiBqZXN0LmZuKCksXG4gICAgICAgIG9uTmV4dDogamVzdC5mbigpLFxuICAgICAgICBvbkJhY2s6IGplc3QuZm4oKVxuICAgICAgfTtcblxuICAgICAgLy8gVXNlIG5ldyByZW5kZXIgZnVuY3Rpb25cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcnMoXG4gICAgICAgIDxUZXN0VXBsb2FkU3RlcFxuICAgICAgICAgIG9uVXBsb2FkQ29tcGxldGU9e21vY2tDYWxsYmFja3Mub25VcGxvYWRDb21wbGV0ZX1cbiAgICAgICAgICBvbkFuYWx5c2lzQ29tcGxldGU9e21vY2tDYWxsYmFja3Mub25BbmFseXNpc0NvbXBsZXRlfVxuICAgICAgICAgIG9uTmV4dD17bW9ja0NhbGxiYWNrcy5vbk5leHR9XG4gICAgICAgICAgb25CYWNrPXttb2NrQ2FsbGJhY2tzLm9uQmFja31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIC8vIFZlcmlmeSB0ZXN0IG1vZGUgYmFubmVyIGlzIHNob3duXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvVGVzdCBNb2RlLykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvTW9jayBkYXRhIHByb3ZpZGVzIHJlbGlhYmxlIHRlc3QgY29udGVudC8pKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuXG4gICAgICAvLyBWZXJpZnkgY29tcG9uZW50IHJlbmRlcnMgY29ycmVjdGx5XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvVXBsb2FkIHBhc3QgdGVzdHMgYW5kIGV4YW1zLykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGVzdElkKFwiYWNjZXB0ZWQtdHlwZXNcIikpLnRvSGF2ZVRleHRDb250ZW50KFwiLnBkZiwuZG9jLC5kb2N4XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHNpbmdsZSB0ZXN0IGZpbGUgdXBsb2FkIHVzaW5nIGZhY3RvcnlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0NhbGxiYWNrcyA9IHtcbiAgICAgICAgb25VcGxvYWRDb21wbGV0ZTogamVzdC5mbigpLFxuICAgICAgICBvbkFuYWx5c2lzQ29tcGxldGU6IGplc3QuZm4oKSxcbiAgICAgICAgb25OZXh0OiBqZXN0LmZuKCksXG4gICAgICAgIG9uQmFjazogamVzdC5mbigpXG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXJzKFxuICAgICAgICA8VGVzdFVwbG9hZFN0ZXBcbiAgICAgICAgICBvblVwbG9hZENvbXBsZXRlPXttb2NrQ2FsbGJhY2tzLm9uVXBsb2FkQ29tcGxldGV9XG4gICAgICAgICAgb25BbmFseXNpc0NvbXBsZXRlPXttb2NrQ2FsbGJhY2tzLm9uQW5hbHlzaXNDb21wbGV0ZX1cbiAgICAgICAgICBvbk5leHQ9e21vY2tDYWxsYmFja3Mub25OZXh0fVxuICAgICAgICAgIG9uQmFjaz17bW9ja0NhbGxiYWNrcy5vbkJhY2t9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyBVc2UgZmFjdG9yeSB0byBjcmVhdGUgdGVzdCBmaWxlXG4gICAgICBjb25zdCB7IGZpbGUgfSA9IGNyZWF0ZVRlc3RGaWxlKHtcbiAgICAgICAgZmlsZU5hbWU6ICdtaWR0ZXJtX2V4YW0ucGRmJyxcbiAgICAgICAgZmlsZVR5cGU6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICBjb250ZW50OiAndGVzdCBjb250ZW50J1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwbG9hZCB0ZXN0IGZpbGVcbiAgICAgIGNvbnN0IGZpbGVJbnB1dCA9IHNjcmVlbi5nZXRCeVRlc3RJZChcImZpbGUtaW5wdXRcIik7XG4gICAgICBhd2FpdCBzaW11bGF0ZUZpbGVVcGxvYWQoZmlsZUlucHV0LCBbZmlsZV0pO1xuXG4gICAgICAvLyBWZXJpZnkgZmlsZSBpcyBsaXN0ZWRcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KFwibWlkdGVybV9leGFtLnBkZlwiKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KFwi8J+nqiBTaW11bGF0aW5nIEFJIGFuYWx5c2lzLi4uXCIpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciBjb21wbGV0aW9uXG4gICAgICBhd2FpdCB3YWl0Rm9yKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG1vY2tDYWxsYmFja3Mub25VcGxvYWRDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICBleHBlY3QuYXJyYXlDb250YWluaW5nKFtcbiAgICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICAgIGlkOiBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxfdGV4dDogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXCJMYW5ndWFnZSBUZWNobm9sb2d5IFF1aXpcIiksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgICAgICAgIGNvdXJzZV90aXRsZTogXCJOYXR1cmFsIExhbmd1YWdlIEludGVyYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB0ZXN0X3RpdGxlOiBcIlF1aXplcyBMYW5nIFRlY2hcIixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIGV4cGVjdC5hbnkoQXJyYXkpLFxuICAgICAgICAgICAgZXhwZWN0LmFueShBcnJheSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB7IHRpbWVvdXQ6IDUwMDAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJGaWxlIFZhbGlkYXRpb24gLSBQYXJhbWV0ZXJpemVkIFRlc3RzXCIsICgpID0+IHtcbiAgICAvLyBVc2UgZmFjdG9yeSB0byBjcmVhdGUgdGVzdCBjYXNlc1xuICAgIGNvbnN0IGZpbGVUZXN0Q2FzZXMgPSBbXG4gICAgICB7IG5hbWU6ICd2YWxpZC5wZGYnLCB0eXBlOiAnYXBwbGljYXRpb24vcGRmJywgc2l6ZTogMTAyNCAqIDEwMjQsIHZhbGlkOiB0cnVlLCBkZXNjcmlwdGlvbjogJ1ZhbGlkIFBERiBmaWxlJyB9LFxuICAgICAgeyBuYW1lOiAnaW52YWxpZC50eHQnLCB0eXBlOiAndGV4dC9wbGFpbicsIHNpemU6IDEwMjQsIHZhbGlkOiBmYWxzZSwgZGVzY3JpcHRpb246ICdJbnZhbGlkIGZpbGUgdHlwZScgfSxcbiAgICAgIHsgbmFtZTogJ292ZXJzaXplZC5wZGYnLCB0eXBlOiAnYXBwbGljYXRpb24vcGRmJywgc2l6ZTogMTYgKiAxMDI0ICogMTAyNCwgdmFsaWQ6IGZhbHNlLCBkZXNjcmlwdGlvbjogJ0ZpbGUgdG9vIGxhcmdlJyB9XG4gICAgXTtcblxuICAgIC8vIFBhcmFtZXRlcml6ZWQgdGVzdCB1c2luZyBmYWN0b3J5IGRhdGFcbiAgICBkZXNjcmliZS5lYWNoKGZpbGVUZXN0Q2FzZXMpKCdGaWxlIFZhbGlkYXRpb24nLCAoeyBuYW1lLCB0eXBlLCBzaXplLCB2YWxpZCwgZGVzY3JpcHRpb24gfSkgPT4ge1xuICAgICAgaXQoYHNob3VsZCAke3ZhbGlkID8gJ2FjY2VwdCcgOiAncmVqZWN0J30gJHtkZXNjcmlwdGlvbn1gLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tDYWxsYmFja3MgPSB7XG4gICAgICAgICAgb25VcGxvYWRDb21wbGV0ZTogamVzdC5mbigpLFxuICAgICAgICAgIG9uQW5hbHlzaXNDb21wbGV0ZTogamVzdC5mbigpLFxuICAgICAgICAgIG9uTmV4dDogamVzdC5mbigpLFxuICAgICAgICAgIG9uQmFjazogamVzdC5mbigpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVuZGVyV2l0aFByb3ZpZGVycyhcbiAgICAgICAgICA8VGVzdFVwbG9hZFN0ZXBcbiAgICAgICAgICAgIG9uVXBsb2FkQ29tcGxldGU9e21vY2tDYWxsYmFja3Mub25VcGxvYWRDb21wbGV0ZX1cbiAgICAgICAgICAgIG9uQW5hbHlzaXNDb21wbGV0ZT17bW9ja0NhbGxiYWNrcy5vbkFuYWx5c2lzQ29tcGxldGV9XG4gICAgICAgICAgICBvbk5leHQ9e21vY2tDYWxsYmFja3Mub25OZXh0fVxuICAgICAgICAgICAgb25CYWNrPXttb2NrQ2FsbGJhY2tzLm9uQmFja31cbiAgICAgICAgICAvPlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0ZXN0IGZpbGUgdXNpbmcgZmFjdG9yeVxuICAgICAgICBjb25zdCB7IGZpbGUgfSA9IGNyZWF0ZVRlc3RGaWxlKHtcbiAgICAgICAgICBmaWxlTmFtZTogbmFtZSxcbiAgICAgICAgICBmaWxlVHlwZTogdHlwZSxcbiAgICAgICAgICBmaWxlU2l6ZTogc2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBmaWxlSW5wdXQgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoXCJmaWxlLWlucHV0XCIpO1xuICAgICAgICBhd2FpdCBzaW11bGF0ZUZpbGVVcGxvYWQoZmlsZUlucHV0LCBbZmlsZV0pO1xuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIC8vIFNob3VsZCBhY2NlcHQgdmFsaWQgZmlsZXNcbiAgICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dChuYW1lKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC9JbnZhbGlkIGZpbGUgdHlwZS8pKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC9GaWxlIGlzIHRvbyBsYXJnZS8pKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3RlOiBJbiB0ZXN0IG1vZGUsIGFsbCBmaWxlcyBhcmUgcHJvY2Vzc2VkIHJlZ2FyZGxlc3Mgb2YgdmFsaWRhdGlvblxuICAgICAgICAgIC8vIFRoaXMgdGVzdCB2ZXJpZmllcyB0aGUgZmlsZSBpcyBkaXNwbGF5ZWRcbiAgICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dChuYW1lKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiQVBJIEVycm9yIEhhbmRsaW5nXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbmV0d29yayBlcnJvcnMgZ3JhY2VmdWxseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBVc2UgY2VudHJhbGl6ZWQgQVBJIG1vY2tcbiAgICAgIGFwaU1vY2tzLm1vY2tOZXR3b3JrRXJyb3IoKTtcblxuICAgICAgY29uc3QgbW9ja0NhbGxiYWNrcyA9IHtcbiAgICAgICAgb25VcGxvYWRDb21wbGV0ZTogamVzdC5mbigpLFxuICAgICAgICBvbkFuYWx5c2lzQ29tcGxldGU6IGplc3QuZm4oKSxcbiAgICAgICAgb25OZXh0OiBqZXN0LmZuKCksXG4gICAgICAgIG9uQmFjazogamVzdC5mbigpXG4gICAgICB9O1xuXG4gICAgICByZW5kZXJXaXRoUHJvdmlkZXJzKFxuICAgICAgICA8VGVzdFVwbG9hZFN0ZXBcbiAgICAgICAgICBvblVwbG9hZENvbXBsZXRlPXttb2NrQ2FsbGJhY2tzLm9uVXBsb2FkQ29tcGxldGV9XG4gICAgICAgICAgb25BbmFseXNpc0NvbXBsZXRlPXttb2NrQ2FsbGJhY2tzLm9uQW5hbHlzaXNDb21wbGV0ZX1cbiAgICAgICAgICBvbk5leHQ9e21vY2tDYWxsYmFja3Mub25OZXh0fVxuICAgICAgICAgIG9uQmFjaz17bW9ja0NhbGxiYWNrcy5vbkJhY2t9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IGZpbGUgfSA9IGNyZWF0ZVRlc3RGaWxlKHsgZmlsZU5hbWU6ICd0ZXN0LnBkZicgfSk7XG4gICAgICBjb25zdCBmaWxlSW5wdXQgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoXCJmaWxlLWlucHV0XCIpO1xuICAgICAgYXdhaXQgc2ltdWxhdGVGaWxlVXBsb2FkKGZpbGVJbnB1dCwgW2ZpbGVdKTtcblxuICAgICAgLy8gSW4gdGVzdCBtb2RlLCBjb21wb25lbnQgdXNlcyBtb2NrIGRhdGEgYW5kIGRvZXNuJ3Qgc2hvdyBuZXR3b3JrIGVycm9yc1xuICAgICAgYXdhaXQgd2FpdEZvcihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KFwi8J+kliBBbmFseXppbmcgdGVzdCBjb250ZW50Li4uXCIpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICB9LFxuICAgICAgICB7IHRpbWVvdXQ6IDUwMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBBUEkgdGltZW91dFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBVc2UgY2VudHJhbGl6ZWQgdGltZW91dCBtb2NrXG4gICAgICBhcGlNb2Nrcy5tb2NrVGltZW91dCgxMDApO1xuXG4gICAgICBjb25zdCBtb2NrQ2FsbGJhY2tzID0ge1xuICAgICAgICBvblVwbG9hZENvbXBsZXRlOiBqZXN0LmZuKCksXG4gICAgICAgIG9uQW5hbHlzaXNDb21wbGV0ZTogamVzdC5mbigpLFxuICAgICAgICBvbk5leHQ6IGplc3QuZm4oKSxcbiAgICAgICAgb25CYWNrOiBqZXN0LmZuKClcbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcldpdGhQcm92aWRlcnMoXG4gICAgICAgIDxUZXN0VXBsb2FkU3RlcFxuICAgICAgICAgIG9uVXBsb2FkQ29tcGxldGU9e21vY2tDYWxsYmFja3Mub25VcGxvYWRDb21wbGV0ZX1cbiAgICAgICAgICBvbkFuYWx5c2lzQ29tcGxldGU9e21vY2tDYWxsYmFja3Mub25BbmFseXNpc0NvbXBsZXRlfVxuICAgICAgICAgIG9uTmV4dD17bW9ja0NhbGxiYWNrcy5vbk5leHR9XG4gICAgICAgICAgb25CYWNrPXttb2NrQ2FsbGJhY2tzLm9uQmFja31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHsgZmlsZSB9ID0gY3JlYXRlVGVzdEZpbGUoeyBmaWxlTmFtZTogJ3Rlc3QucGRmJyB9KTtcbiAgICAgIGNvbnN0IGZpbGVJbnB1dCA9IHNjcmVlbi5nZXRCeVRlc3RJZChcImZpbGUtaW5wdXRcIik7XG4gICAgICBhd2FpdCBzaW11bGF0ZUZpbGVVcGxvYWQoZmlsZUlucHV0LCBbZmlsZV0pO1xuXG4gICAgICAvLyBDb21wb25lbnQgc2hvdWxkIGhhbmRsZSB0aW1lb3V0IGdyYWNlZnVsbHlcbiAgICAgIGF3YWl0IHdhaXRGb3IoXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dChcIvCfpJYgQW5hbHl6aW5nIHRlc3QgY29udGVudC4uLlwiKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyB0aW1lb3V0OiA1MDAwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbInRlc3RFbnYiLCJzZXR1cEZ1bGxUZXN0RW52aXJvbm1lbnQiLCJ0aW1lb3V0IiwiaW5jbHVkZUFQSSIsImluY2x1ZGVTdG9yYWdlIiwiaW5jbHVkZU5hdmlnYXRpb24iLCJjcmVhdGVUZXN0RmlsZSIsInRlc3RGYWN0b3JpZXMiLCJhcGlNb2NrcyIsInN0YW5kYXJkTW9ja3MiLCJzaW11bGF0ZUZpbGVVcGxvYWQiLCJmaWxlSW5wdXQiLCJmaWxlcyIsImFjdCIsImZpcmVFdmVudCIsImNoYW5nZSIsInRhcmdldCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsIm1vY2tzIiwicmVzZXRBbGwiLCJzZXR1cE1vY2tSZXNwb25zZXMiLCJvayIsInN0YXR1cyIsImpzb24iLCJpZCIsIml0IiwibW9ja0NhbGxiYWNrcyIsIm9uVXBsb2FkQ29tcGxldGUiLCJqZXN0IiwiZm4iLCJvbkFuYWx5c2lzQ29tcGxldGUiLCJvbk5leHQiLCJvbkJhY2siLCJyZW5kZXJXaXRoUHJvdmlkZXJzIiwiVGVzdFVwbG9hZFN0ZXAiLCJleHBlY3QiLCJzY3JlZW4iLCJnZXRCeVRleHQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsImdldEJ5VGVzdElkIiwidG9IYXZlVGV4dENvbnRlbnQiLCJmaWxlIiwiZmlsZU5hbWUiLCJmaWxlVHlwZSIsImNvbnRlbnQiLCJ3YWl0Rm9yIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJhcnJheUNvbnRhaW5pbmciLCJvYmplY3RDb250YWluaW5nIiwiYW55IiwiTnVtYmVyIiwib3JpZ2luYWxfdGV4dCIsInN0cmluZ0NvbnRhaW5pbmciLCJtZXRhZGF0YSIsImNvdXJzZV90aXRsZSIsInRlc3RfdGl0bGUiLCJBcnJheSIsImZpbGVUZXN0Q2FzZXMiLCJuYW1lIiwidHlwZSIsInNpemUiLCJ2YWxpZCIsImRlc2NyaXB0aW9uIiwiZWFjaCIsImZpbGVTaXplIiwicXVlcnlCeVRleHQiLCJub3QiLCJtb2NrTmV0d29ya0Vycm9yIiwibW9ja1RpbWVvdXQiXSwibWFwcGluZ3MiOiI7Ozs7OytEQUF1Qjt3QkFDeUI7UUFDekM7Z0NBQ3dCOzJCQVF4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRVAsNkNBQTZDO0FBQzdDLE1BQU1BLFVBQVVDLElBQUFBLG1DQUF3QixFQUFDO0lBQ3ZDQyxTQUFTO0lBQ1RDLFlBQVk7SUFDWkMsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7QUFDckI7QUFFQSxzQ0FBc0M7QUFDdEMsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0Msd0JBQWE7QUFDeEMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Msd0JBQWE7QUFFbEMsMENBQTBDO0FBQzFDLE1BQU1DLHFCQUFxQixPQUFPQyxXQUF3QkM7SUFDeEQsTUFBTUMsSUFBQUEsV0FBRyxFQUFDO1FBQ1JDLGlCQUFTLENBQUNDLE1BQU0sQ0FBQ0osV0FBVztZ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