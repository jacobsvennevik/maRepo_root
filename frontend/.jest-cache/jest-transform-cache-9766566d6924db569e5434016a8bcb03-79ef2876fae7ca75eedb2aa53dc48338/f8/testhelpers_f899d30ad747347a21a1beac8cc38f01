9bd0a17e54c5cae68451bdd1a043f60d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    actAndWait: function() {
        return actAndWait;
    },
    createAfterEach: function() {
        return createAfterEach;
    },
    createBeforeEach: function() {
        return createBeforeEach;
    },
    createLocalStorageMock: function() {
        return createLocalStorageMock;
    },
    createMockBackendData: function() {
        return createMockBackendData;
    },
    createMockFetch: function() {
        return createMockFetch;
    },
    createMockProjectSetup: function() {
        return createMockProjectSetup;
    },
    createRouterMock: function() {
        return createRouterMock;
    },
    createTestFile: function() {
        return createTestFile;
    },
    resetTestEnvironment: function() {
        return resetTestEnvironment;
    },
    setTestEnvironment: function() {
        return setTestEnvironment;
    },
    setupFullTestEnvironment: function() {
        return setupFullTestEnvironment;
    },
    setupTestCleanup: function() {
        return setupTestCleanup;
    },
    setupTestEnvironment: function() {
        return setupTestEnvironment;
    },
    simulateFileUpload: function() {
        return simulateFileUpload;
    }
});
const _react = require("@testing-library/react");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const createLocalStorageMock = ()=>{
    const storage = {};
    const localStorageMock = {
        getItem: jest.fn((key)=>storage[key] || null),
        setItem: jest.fn((key, value)=>{
            storage[key] = value;
        }),
        removeItem: jest.fn((key)=>{
            delete storage[key];
        }),
        clear: jest.fn(()=>{
            Object.keys(storage).forEach((key)=>delete storage[key]);
        })
    };
    Object.defineProperty(window, "localStorage", {
        value: localStorageMock,
        writable: true
    });
    return localStorageMock;
};
const createRouterMock = ()=>{
    jest.mock("next/navigation", ()=>({
            useRouter: ()=>({
                    push: mockPush,
                    replace: mockReplace,
                    prefetch: mockPrefetch,
                    back: mockBack,
                    forward: mockForward,
                    refresh: mockRefresh
                })
        }));
    const mockPush = jest.fn();
    const mockReplace = jest.fn();
    const mockPrefetch = jest.fn();
    const mockBack = jest.fn();
    const mockForward = jest.fn();
    const mockRefresh = jest.fn();
    return {
        mockPush,
        mockReplace,
        mockPrefetch,
        mockBack,
        mockForward,
        mockRefresh
    };
};
const createMockProjectSetup = (overrides = {})=>({
        projectName: "Test Project",
        purpose: "school",
        testLevel: "midterm",
        courseFiles: [],
        testFiles: [],
        importantDates: [],
        uploadedFiles: [],
        timeframe: "semester",
        goal: "pass",
        studyFrequency: "weekly",
        collaboration: "solo",
        ...overrides
    });
const createTestFile = (name = "test.pdf", content = "test content", type = "application/pdf")=>{
    return new File([
        content
    ], name, {
        type
    });
};
const createMockBackendData = (overrides = {})=>({
        id: 123,
        original_text: "Course content",
        metadata: {
            course_name: "Test Course"
        },
        status: "completed",
        ...overrides
    });
const setupTestCleanup = (mocks = [])=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        mocks.forEach((mock)=>{
            if (mock && typeof mock.mockClear === "function") {
                mock.mockClear();
            }
        });
    });
};
const createAfterEach = ()=>()=>{
    // no-op placeholder to satisfy tests that call afterEach(createAfterEach())
    };
const createBeforeEach = (_isTestMode)=>()=>{
    // no-op placeholder; specific suites use upload-test-helpers createUploadTestSetup
    };
const createMockFetch = ()=>{
    const mockFetch = jest.fn();
    global.fetch = mockFetch;
    return mockFetch;
};
const simulateFileUpload = async (fileInput, files)=>{
    const fileList = Array.isArray(files) ? files : [
        files
    ];
    await (0, _react.act)(async ()=>{
        _react.fireEvent.change(fileInput, {
            target: {
                files: fileList
            }
        });
    });
};
const actAndWait = async (callback)=>{
    const { act, waitFor } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("@testing-library/react")));
    await act(async ()=>{
        await callback();
    });
    return waitFor;
};
const setupTestEnvironment = (env)=>{
    const originalEnv = process.env;
    beforeEach(()=>{
        process.env = {
            ...originalEnv,
            ...env
        };
    });
    afterEach(()=>{
        process.env = originalEnv;
    });
};
const setupFullTestEnvironment = ()=>{
    const localStorageMock = createLocalStorageMock();
    const routerMocks = createRouterMock();
    const mockFetch = createMockFetch();
    setupTestCleanup([
        mockFetch
    ]);
    return {
        localStorageMock,
        routerMocks,
        mockFetch
    };
};
// Environment helpers
const processEnvMock = {
    NODE_ENV: "test",
    NEXT_PUBLIC_TEST_MODE: "false"
};
Object.defineProperty(process, "env", {
    get: ()=>processEnvMock,
    set: (value)=>{
        Object.assign(processEnvMock, value);
    }
});
const setTestEnvironment = (env)=>{
    Object.assign(processEnvMock, env);
};
const resetTestEnvironment = ()=>{
    Object.assign(processEnvMock, {
        NODE_ENV: "test",
        NEXT_PUBLIC_TEST_MODE: "false"
    });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYmhvcm5zdmVubmV2aWsvRG9jdW1lbnRzL0dpdEh1Yi9tYVJlcG9fcm9vdC9mcm9udGVuZC9zcmMvdGVzdC11dGlscy90ZXN0LWhlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvamVjdFNldHVwIH0gZnJvbSBcIi4uL2ZlYXR1cmVzL3Byb2plY3RzL3R5cGVzL2luZGV4XCI7XG5pbXBvcnQgeyBmaXJlRXZlbnQsIGFjdCB9IGZyb20gXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1vY2sgbG9jYWxTdG9yYWdlIG9iamVjdCBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTG9jYWxTdG9yYWdlTW9jayA9ICgpID0+IHtcbiAgY29uc3Qgc3RvcmFnZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gIGNvbnN0IGxvY2FsU3RvcmFnZU1vY2sgPSB7XG4gICAgZ2V0SXRlbTogamVzdC5mbigoa2V5OiBzdHJpbmcpID0+IHN0b3JhZ2Vba2V5XSB8fCBudWxsKSxcbiAgICBzZXRJdGVtOiBqZXN0LmZuKChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgfSksXG4gICAgcmVtb3ZlSXRlbTogamVzdC5mbigoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIGRlbGV0ZSBzdG9yYWdlW2tleV07XG4gICAgfSksXG4gICAgY2xlYXI6IGplc3QuZm4oKCkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZSkuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGUgc3RvcmFnZVtrZXldKTtcbiAgICB9KSxcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImxvY2FsU3RvcmFnZVwiLCB7XG4gICAgdmFsdWU6IGxvY2FsU3RvcmFnZU1vY2ssXG4gICAgd3JpdGFibGU6IHRydWUsXG4gIH0pO1xuXG4gIHJldHVybiBsb2NhbFN0b3JhZ2VNb2NrO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbW9jayBOZXh0LmpzIHJvdXRlciBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyTW9jayA9ICgpID0+IHtcbiAgY29uc3QgbW9ja1B1c2ggPSBqZXN0LmZuKCk7XG4gIGNvbnN0IG1vY2tSZXBsYWNlID0gamVzdC5mbigpO1xuICBjb25zdCBtb2NrUHJlZmV0Y2ggPSBqZXN0LmZuKCk7XG4gIGNvbnN0IG1vY2tCYWNrID0gamVzdC5mbigpO1xuICBjb25zdCBtb2NrRm9yd2FyZCA9IGplc3QuZm4oKTtcbiAgY29uc3QgbW9ja1JlZnJlc2ggPSBqZXN0LmZuKCk7XG5cbiAgamVzdC5tb2NrKFwibmV4dC9uYXZpZ2F0aW9uXCIsICgpID0+ICh7XG4gICAgdXNlUm91dGVyOiAoKSA9PiAoe1xuICAgICAgcHVzaDogbW9ja1B1c2gsXG4gICAgICByZXBsYWNlOiBtb2NrUmVwbGFjZSxcbiAgICAgIHByZWZldGNoOiBtb2NrUHJlZmV0Y2gsXG4gICAgICBiYWNrOiBtb2NrQmFjayxcbiAgICAgIGZvcndhcmQ6IG1vY2tGb3J3YXJkLFxuICAgICAgcmVmcmVzaDogbW9ja1JlZnJlc2gsXG4gICAgfSksXG4gIH0pKTtcblxuICByZXR1cm4ge1xuICAgIG1vY2tQdXNoLFxuICAgIG1vY2tSZXBsYWNlLFxuICAgIG1vY2tQcmVmZXRjaCxcbiAgICBtb2NrQmFjayxcbiAgICBtb2NrRm9yd2FyZCxcbiAgICBtb2NrUmVmcmVzaCxcbiAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlZmF1bHQgcHJvamVjdCBzZXR1cCBvYmplY3QgZm9yIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vY2tQcm9qZWN0U2V0dXAgPSAoXG4gIG92ZXJyaWRlczogUGFydGlhbDxQcm9qZWN0U2V0dXA+ID0ge30sXG4pOiBQcm9qZWN0U2V0dXAgPT4gKHtcbiAgcHJvamVjdE5hbWU6IFwiVGVzdCBQcm9qZWN0XCIsXG4gIHB1cnBvc2U6IFwic2Nob29sXCIgYXMgY29uc3QsXG4gIHRlc3RMZXZlbDogXCJtaWR0ZXJtXCIgYXMgY29uc3QsXG4gIGNvdXJzZUZpbGVzOiBbXSxcbiAgdGVzdEZpbGVzOiBbXSxcbiAgaW1wb3J0YW50RGF0ZXM6IFtdLFxuICB1cGxvYWRlZEZpbGVzOiBbXSxcbiAgdGltZWZyYW1lOiBcInNlbWVzdGVyXCIgYXMgY29uc3QsXG4gIGdvYWw6IFwicGFzc1wiIGFzIGNvbnN0LFxuICBzdHVkeUZyZXF1ZW5jeTogXCJ3ZWVrbHlcIiBhcyBjb25zdCxcbiAgY29sbGFib3JhdGlvbjogXCJzb2xvXCIgYXMgY29uc3QsXG4gIC4uLm92ZXJyaWRlcyxcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXN0IGZpbGUgZm9yIGZpbGUgdXBsb2FkIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlc3RGaWxlID0gKFxuICBuYW1lOiBzdHJpbmcgPSBcInRlc3QucGRmXCIsXG4gIGNvbnRlbnQ6IHN0cmluZyA9IFwidGVzdCBjb250ZW50XCIsXG4gIHR5cGU6IHN0cmluZyA9IFwiYXBwbGljYXRpb24vcGRmXCIsXG4pOiBGaWxlID0+IHtcbiAgcmV0dXJuIG5ldyBGaWxlKFtjb250ZW50XSwgbmFtZSwgeyB0eXBlIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIG1vY2sgYmFja2VuZCBkYXRhIHN0cnVjdHVyZVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTW9ja0JhY2tlbmREYXRhID0gKG92ZXJyaWRlczogYW55ID0ge30pID0+ICh7XG4gIGlkOiAxMjMsXG4gIG9yaWdpbmFsX3RleHQ6IFwiQ291cnNlIGNvbnRlbnRcIixcbiAgbWV0YWRhdGE6IHsgY291cnNlX25hbWU6IFwiVGVzdCBDb3Vyc2VcIiB9LFxuICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gIC4uLm92ZXJyaWRlcyxcbn0pO1xuXG4vKipcbiAqIFNldHMgdXAgY29tbW9uIHRlc3QgZW52aXJvbm1lbnQgY2xlYW51cFxuICovXG5leHBvcnQgY29uc3Qgc2V0dXBUZXN0Q2xlYW51cCA9IChtb2NrczogYW55W10gPSBbXSkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBtb2Nrcy5mb3JFYWNoKChtb2NrKSA9PiB7XG4gICAgICBpZiAobW9jayAmJiB0eXBlb2YgbW9jay5tb2NrQ2xlYXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBtb2NrLm1vY2tDbGVhcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmxlIGFsaWFzZXMgZm9yIHRlc3RzIGV4cGVjdGluZyBkaWZmZXJlbnQgbmFtZXNcbmV4cG9ydCBjb25zdCBjcmVhdGVBZnRlckVhY2ggPSAoKSA9PiAoKSA9PiB7XG4gIC8vIG5vLW9wIHBsYWNlaG9sZGVyIHRvIHNhdGlzZnkgdGVzdHMgdGhhdCBjYWxsIGFmdGVyRWFjaChjcmVhdGVBZnRlckVhY2goKSlcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQmVmb3JlRWFjaCA9IChfaXNUZXN0TW9kZT86IGJvb2xlYW4pID0+ICgpID0+IHtcbiAgLy8gbm8tb3AgcGxhY2Vob2xkZXI7IHNwZWNpZmljIHN1aXRlcyB1c2UgdXBsb2FkLXRlc3QtaGVscGVycyBjcmVhdGVVcGxvYWRUZXN0U2V0dXBcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1vY2sgZmV0Y2ggaW1wbGVtZW50YXRpb24gZm9yIEFQSSB0ZXN0aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNb2NrRmV0Y2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKTtcbiAgZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGZldGNoPjtcbiAgcmV0dXJuIG1vY2tGZXRjaDtcbn07XG5cbi8qKlxuICogSGVscGVyIHRvIHNpbXVsYXRlIGZpbGUgdXBsb2FkIGluIHRlc3RzXG4gKi9cbmV4cG9ydCBjb25zdCBzaW11bGF0ZUZpbGVVcGxvYWQgPSBhc3luYyAoXG4gIGZpbGVJbnB1dDogSFRNTEVsZW1lbnQsXG4gIGZpbGVzOiBGaWxlIHwgRmlsZVtdLFxuKSA9PiB7XG4gIGNvbnN0IGZpbGVMaXN0ID0gQXJyYXkuaXNBcnJheShmaWxlcykgPyBmaWxlcyA6IFtmaWxlc107XG4gIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgZmlyZUV2ZW50LmNoYW5nZShmaWxlSW5wdXQsIHtcbiAgICAgIHRhcmdldDoge1xuICAgICAgICBmaWxlczogZmlsZUxpc3QsXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogSGVscGVyIHRvIHdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnMgd2l0aCBhY3Qgd3JhcHBlclxuICovXG5leHBvcnQgY29uc3QgYWN0QW5kV2FpdCA9IGFzeW5jIChjYWxsYmFjazogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4pID0+IHtcbiAgY29uc3QgeyBhY3QsIHdhaXRGb3IgfSA9IGF3YWl0IGltcG9ydChcIkB0ZXN0aW5nLWxpYnJhcnkvcmVhY3RcIik7XG5cbiAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjYWxsYmFjaygpO1xuICB9KTtcblxuICByZXR1cm4gd2FpdEZvcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBlbnZpcm9ubWVudCB2YXJpYWJsZSBzZXR1cCBmb3IgdGVzdHNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldHVwVGVzdEVudmlyb25tZW50ID0gKGVudjogUmVjb3JkPHN0cmluZywgc3RyaW5nPikgPT4ge1xuICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIHByb2Nlc3MuZW52ID0ge1xuICAgICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgICAuLi5lbnYsXG4gICAgfTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXByZWhlbnNpdmUgdGVzdCBzZXR1cCB3aXRoIGFsbCBjb21tb24gbW9ja3NcbiAqL1xuZXhwb3J0IGNvbnN0IHNldHVwRnVsbFRlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgY29uc3QgbG9jYWxTdG9yYWdlTW9jayA9IGNyZWF0ZUxvY2FsU3RvcmFnZU1vY2soKTtcbiAgY29uc3Qgcm91dGVyTW9ja3MgPSBjcmVhdGVSb3V0ZXJNb2NrKCk7XG4gIGNvbnN0IG1vY2tGZXRjaCA9IGNyZWF0ZU1vY2tGZXRjaCgpO1xuXG4gIHNldHVwVGVzdENsZWFudXAoW21vY2tGZXRjaF0pO1xuXG4gIHJldHVybiB7XG4gICAgbG9jYWxTdG9yYWdlTW9jayxcbiAgICByb3V0ZXJNb2NrcyxcbiAgICBtb2NrRmV0Y2gsXG4gIH07XG59O1xuXG4vLyBFbnZpcm9ubWVudCBoZWxwZXJzXG5jb25zdCBwcm9jZXNzRW52TW9jayA9IHtcbiAgTk9ERV9FTlY6IFwidGVzdFwiLFxuICBORVhUX1BVQkxJQ19URVNUX01PREU6IFwiZmFsc2VcIixcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzLCBcImVudlwiLCB7XG4gIGdldDogKCkgPT4gcHJvY2Vzc0Vudk1vY2ssXG4gIHNldDogKHZhbHVlKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihwcm9jZXNzRW52TW9jaywgdmFsdWUpO1xuICB9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBzZXRUZXN0RW52aXJvbm1lbnQgPSAoZW52OiBQYXJ0aWFsPHR5cGVvZiBwcm9jZXNzRW52TW9jaz4pID0+IHtcbiAgT2JqZWN0LmFzc2lnbihwcm9jZXNzRW52TW9jaywgZW52KTtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNldFRlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihwcm9jZXNzRW52TW9jaywge1xuICAgIE5PREVfRU5WOiBcInRlc3RcIixcbiAgICBORVhUX1BVQkxJQ19URVNUX01PREU6IFwiZmFsc2VcIixcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbImFjdEFuZFdhaXQiLCJjcmVhdGVBZnRlckVhY2giLCJjcmVhdGVCZWZvcmVFYWNoIiwiY3JlYXRlTG9jYWxTdG9yYWdlTW9jayIsImNyZWF0ZU1vY2tCYWNrZW5kRGF0YSIsImNyZWF0ZU1vY2tGZXRjaCIsImNyZWF0ZU1vY2tQcm9qZWN0U2V0dXAiLCJjcmVhdGVSb3V0ZXJNb2NrIiwiY3JlYXRlVGVzdEZpbGUiLCJyZXNldFRlc3RFbnZpcm9ubWVudCIsInNldFRlc3RFbnZpcm9ubWVudCIsInNldHVwRnVsbFRlc3RFbnZpcm9ubWVudCIsInNldHVwVGVzdENsZWFudXAiLCJzZXR1cFRlc3RFbnZpcm9ubWVudCIsInNpbXVsYXRlRmlsZVVwbG9hZCIsInN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2VNb2NrIiwiZ2V0SXRlbSIsImplc3QiLCJmbiIsImtleSIsInNldEl0ZW0iLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iLCJjbGVhciIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ3cml0YWJsZSIsIm1vY2siLCJ1c2VSb3V0ZXIiLCJwdXNoIiwibW9ja1B1c2giLCJyZXBsYWNlIiwibW9ja1JlcGxhY2UiLCJwcmVmZXRjaCIsIm1vY2tQcmVmZXRjaCIsImJhY2siLCJtb2NrQmFjayIsImZvcndhcmQiLCJtb2NrRm9yd2FyZCIsInJlZnJlc2giLCJtb2NrUmVmcmVzaCIsIm92ZXJyaWRlcyIsInByb2plY3ROYW1lIiwicHVycG9zZSIsInRlc3RMZXZlbCIsImNvdXJzZUZpbGVzIiwidGVzdEZpbGVzIiwiaW1wb3J0YW50RGF0ZXMiLCJ1cGxvYWRlZEZpbGVzIiwidGltZWZyYW1lIiwiZ29hbCIsInN0dWR5RnJlcXVlbmN5IiwiY29sbGFib3JhdGlvbiIsIm5hbWUiLCJjb250ZW50IiwidHlwZSIsIkZpbGUiLCJpZCIsIm9yaWdpbmFsX3RleHQiLCJtZXRhZGF0YSIsImNvdXJzZV9uYW1lIiwic3RhdHVzIiwibW9ja3MiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsIl9pc1Rlc3RNb2RlIiwibW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJmaWxlSW5wdXQiLCJmaWxlcyIsImZpbGVMaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiYWN0IiwiZmlyZUV2ZW50IiwiY2hhbmdlIiwidGFyZ2V0IiwiY2FsbGJhY2siLCJ3YWl0Rm9yIiwiZW52Iiwib3JpZ2luYWxFbnYiLCJwcm9jZXNzIiwiYWZ0ZXJFYWNoIiwicm91dGVyTW9ja3MiLCJwcm9jZXNzRW52TW9jayIsIk5PREVfRU5WIiwiTkVYVF9QVUJMSUNfVEVTVF9NT0RFIiwiZ2V0Iiwic2V0IiwiYXNzaWduIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQTJKYUEsVUFBVTtlQUFWQTs7SUFwQ0FDLGVBQWU7ZUFBZkE7O0lBR0FDLGdCQUFnQjtlQUFoQkE7O0lBcEhBQyxzQkFBc0I7ZUFBdEJBOztJQTBGQUMscUJBQXFCO2VBQXJCQTs7SUFpQ0FDLGVBQWU7ZUFBZkE7O0lBaEVBQyxzQkFBc0I7ZUFBdEJBOztJQWhDQUMsZ0JBQWdCO2VBQWhCQTs7SUFvREFDLGNBQWM7ZUFBZEE7O0lBb0lBQyxvQkFBb0I7ZUFBcEJBOztJQUpBQyxrQkFBa0I7ZUFBbEJBOztJQTNCQUMsd0JBQXdCO2VBQXhCQTs7SUEvRUFDLGdCQUFnQjtlQUFoQkE7O0lBNkRBQyxvQkFBb0I7ZUFBcEJBOztJQTlCQUMsa0JBQWtCO2VBQWxCQTs7O3VCQXpJa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUt4QixNQUFNWCx5QkFBeUI7SUFDcEMsTUFBTVksVUFBcUMsQ0FBQztJQUU1QyxNQUFNQyxtQkFBbUI7UUFDdkJDLFNBQVNDLEtBQUtDLEVBQUUsQ0FBQyxDQUFDQyxNQUFnQkwsT0FB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