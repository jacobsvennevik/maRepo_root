{
  "ai": {
    "instructions": [
      "The user is an expert-level programmer. Please do not explain trivial concepts.",
      "The project is a web application built with Next.js, React, TypeScript, and Tailwind CSS.",
      "When generating code, follow the existing coding style and conventions.",
      "For React components, prefer functional components with hooks.",
      "All file paths should be relative to the workspace root.",
      "--- DJANGO BACKEND WORKFLOW ---",
      "STEP 1: Optimize Django Performance - Use select_related / prefetch_related to reduce N+1 queries.",
      "STEP 1: Optimize Django Performance - Add db_index=True to frequently filtered fields.",
      "STEP 1: Optimize Django Performance - Profile queries and views with Django Debug Toolbar or cProfile.",
      "STEP 1: Optimize Django Performance - Use Redis or Memcached for caching.",
      "STEP 1: Optimize Django Performance - Set CONN_MAX_AGE in production for persistent DB connections.",
      "STEP 1: Optimize Django Performance - Offload tasks like emails to Celery + Redis.",
      "STEP 2: Build Clean, Modular Architecture - Split project into feature-specific Django apps (e.g., users, orders).",
      "STEP 2: Build Clean, Modular Architecture - Keep views light; put logic in services.py or model methods.",
      "STEP 2: Build Clean, Modular Architecture - Use signals to decouple logic between apps.",
      "STEP 2: Build Clean, Modular Architecture - Organize project under a clear directory structure (e.g., apps/, services/).",
      "STEP 3: Design for Scalability - Use Celery for background jobs.",
      "STEP 3: Design for Scalability - Implement caching at view, object, or API level.",
      "STEP 3: Design for Scalability - Optimize PostgreSQL: indexes, query analysis, and optionally replicas.",
      "STEP 3: Design for Scalability - Deploy using Docker for portability and environment consistency.",
      "STEP 3: Design for Scalability - Production stack: Gunicorn + Nginx + Celery + Redis + PostgreSQL.",
      "STEP 4: Apply Strong Security Measures - Enforce HTTPS and set secure cookies (SESSION_COOKIE_SECURE, etc.).",
      "STEP 4: Apply Strong Security Measures - Store secrets in environment variables, not code.",
      "STEP 4: Apply Strong Security Measures - Enable CSRF protection and same-site cookie rules.",
      "STEP 4: Apply Strong Security Measures - Throttle requests using django-ratelimit or DRF throttling.",
      "STEP 4: Apply Strong Security Measures - Harden headers (HSTS, Content Security Policy, X-Frame-Options).",
      "STEP 4: Apply Strong Security Measures - Use drf-simplejwt or secure session management for user auth.",
      "STEP 5: Design Stable, Useful APIs - Use Django REST Framework (or Graphene for GraphQL).",
      "STEP 5: Design Stable, Useful APIs - Prefix routes with versions (/api/v1/...).",
      "STEP 5: Design Stable, Useful APIs - Use PageNumberPagination or CursorPagination to manage large datasets.",
      "STEP 5: Design Stable, Useful APIs - Filter queries with django-filter.",
      "STEP 5: Design Stable, Useful APIs - Auto-generate OpenAPI docs using drf-spectacular.",
      "STEP 6: Integrate with React Frontend - Add django-cors-headers and whitelist your frontend domain.",
      "STEP 6: Integrate with React Frontend - Use JWT auth (preferred) or session + CSRF for auth.",
      "STEP 6: Integrate with React Frontend - Include CSRF_TRUSTED_ORIGINS if using cookie/session auth.",
      "STEP 6: Integrate with React Frontend - Centralize fetch logic in React with Axios interceptors or React Query.",
      "STEP 6: Integrate with React Frontend - Handle token refresh logic for JWT.",
      "STEP 7: Test, Monitor, Maintain - Write tests for views, serializers, models, and API endpoints with pytest.",
      "STEP 7: Test, Monitor, Maintain - Use tools like Sentry and Prometheus for error tracking and performance monitoring.",
      "STEP 7: Test, Monitor, Maintain - Run pip-audit regularly to detect package vulnerabilities.",
      "STEP 7: Test, Monitor, Maintain - Use CI tools (GitHub Actions, GitLab CI) with linters and formatters.",
      "Bonus Tips: Use WhiteNoise or a CDN for static file delivery. Keep API and code well documented. Explore Django Channels for real-time features. Extract reusable logic into Django apps.",
      "--- REACT FRONTEND WORKFLOW ---",
      "STEP 1: Improve Loading Performance - Use React.lazy() with <Suspense> to lazy-load non-essential components.",
      "STEP 1: Improve Loading Performance - Split code by route using dynamic import() or frameworks like Next.js.",
      "STEP 1: Improve Loading Performance - Apply loading='lazy' for off-screen images and assets.",
      "STEP 2: Optimize Component Rendering - Use React.memo() to prevent re-rendering stable components.",
      "STEP 2: Optimize Component Rendering - Apply useMemo() for expensive calculations and useCallback() for functions passed to child components.",
      "STEP 2: Optimize Component Rendering - Profile with React DevTools Profiler to find real bottlenecks.",
      "STEP 3: Server-Side Rendering & Hydration - Use Next.js or Remix for SSR.",
      "STEP 3: Server-Side Rendering & Hydration - Avoid non-deterministic content during render (Date.now(), Math.random()).",
      "STEP 3: Server-Side Rendering & Hydration - Use selective hydration for low-priority components with dynamic(import, { ssr: false }).",
      "STEP 4: Runtime Responsiveness - Virtualize long lists using react-window.",
      "STEP 4: Runtime Responsiveness - Throttle or debounce scroll/resize handlers.",
      "STEP 4: Runtime Responsiveness - Offload expensive logic to Web Workers (e.g., with Comlink).",
      "STEP 4: Runtime Responsiveness - Use useTransition and useDeferredValue for smoother, deferred UI updates.",
      "STEP 5: Use a Design System - Choose a UI library: MUI, or Tailwind CSS + Radix UI + shadcn UI.",
      "STEP 5: Use a Design System - Centralize styling with design tokens (e.g., spacing, colors, fonts).",
      "STEP 6: Ensure Accessibility (WCAG) - Use semantic HTML and ARIA attributes.",
      "STEP 6: Ensure Accessibility (WCAG) - Ensure keyboard support for all interactive elements.",
      "STEP 6: Ensure Accessibility (WCAG) - Test using Lighthouse, axe, and manual screen reader/keyboard checks.",
      "STEP 7: Build for Responsiveness - Use flexbox/grid and media queries or Tailwind breakpoints.",
      "STEP 7: Build for Responsiveness - Set <meta name='viewport' content='width=device-width, initial-scale=1'>.",
      "STEP 7: Build for Responsiveness - Test on real and emulated devices.",
      "STEP 8: Collaborate with Figma & Storybook - Use Figma to inspect designs and discuss edge cases early.",
      "STEP 8: Collaborate with Figma & Storybook - Maintain a Storybook to showcase UI components in isolation.",
      "Final Advice: Measure first, optimize second. Use design systems. Embrace accessibility and responsiveness."
    ]
  }
} 